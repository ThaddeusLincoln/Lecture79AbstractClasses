Abstraction : is when we specify the required functionality for something without specifying the how.
We're focusing on what needs to be done, not on the how it's to be done.

Interfaces : are purely or 100% abstract, which do not implement any aspect of the implementation which 
has to take place in the actual classes.

When putting a List to be used from our Interface, it's better to actually use a List<?> which is an Interface,
and  gives the possibility of using any class that implements it. This wouldn't be possible if we use, 
ArrayList<?> or any other.

Abstract classes : provide methods, but do not provide an implementation of it. One of the big differences
with interfaces is that not all methods need to be abstract.

As not all birds can fly, it's not a good idea put a fly() method in Bird class. Instead it'll be better to
create an Abstract Bird class that extends Animal and has an abstract fly method that each class will
implement as they're able to.
 
 Relationships:

1 - "is a"  : inheritance
2 - "has a" : composition
3 - "can"   : interface

In the design we have so far, we run into a problem an is that fly is not inherit to Birds, as bats
can fly an bats are mammals. So a solution would be create a ICanFly interface, to be implement by
any animal that has this capability. Using an "I" is a naming convention used widely in C#, 
but not mandatory neither in C# nor Java.

Abstract class vs. Interfaces:

Abstract class : can have member variables (this can't be done in an interface)
Interfaces can have variables, but they are all public static final variables (essentially a CONSTANT).
And they do have to be static, because non-static variables need of an instance, 
and you can't instantiate an interface. Interfaces also can't have constructors, but abstract classes can.
All methods in an interface are automatically public, whereas the methods of an abstract class can have any visibility. 
Abstract classes can have defined methods (those which are not abstract).

Search Tree: is very similar to a LinkedList, the differences are mainly in the implementations of addItem, removeItem(), 
and traverse() methods.

Binary Search Tree, the way we add items respect a given order which allows search to be optimized.

