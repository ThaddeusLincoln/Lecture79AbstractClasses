Abstraction : is when we specify the required functionality for something without specifying the how.
We're focusing on what needs to be done, not on the how it's to be done.

Interfaces : are purely or 100% abstract, which do not implement any aspect of the implementation which 
has to take place in the actual classes.

When putting a List to be used from our Interface, it's better to actually use a List<?> which is an Interface,
and  gives the possibility of using any class that implements it. This wouldn't be possible if we use, 
ArrayList<?> or any other.

Abstract classes : provide methods, but do not provide an implementation of it. One of the big differences
with interfaces is that not all methods need to be abstract.

As not all birds can fly, it's not a good idea put a fly() method in Bird class. Instead it'll be better to
create an Abstract Bird class that extends Animal and has an abstract fly method that each class will
implement as they're able to.
 
 Relationships:

1 - "is a"  : inheritance
2 - "has a" : composition
3 - "can"   : interface

In the design we have so far, we run into a problem an is that fly is not inherit to Birds, as bats
can fly an bats are mammals. So a solution would be create a ICanFly interface, to be implement by
any animal that has this capability. Using an "I" is a naming convention used widely in C#, 
but not mandatory neither in C# nor Java.
